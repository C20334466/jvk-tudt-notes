---
title: "Visualisation with R (examples from The Book of R)"
author: "JV (a transcription of The Book of R chapters 14, 23, 24, 25)"
output: 
   html_document:
      toc: true
      toc_depth: 3
---

# Basic visualisation with R

## Difference between base R graphics and ggplot2
With base R it is easier to exercise control over the details of a plot, while `ggplot2` is more powerful in the presentation of complex datasets where the separation of subsets by categorical variables needs to be shown. The `ggplot2` package is also better at producing quick graphs that look presentable enough. 

**NOTE: In the following examples a data set available in R called `mtcars` is used.**
```{r}
head(mtcars)
```

## Barcharts
Barcharts are for nominal data.

### Barchart with base R
```{r}
cyl.freq<-table(mtcars$cyl)
cyl.freq
barplot(cyl.freq)
```

### Dodged barchart with base R
```{r}
cyl.freq.matrix<-table(mtcars$am, mtcars$cyl)
cyl.freq.matrix
barplot(cyl.freq.matrix, beside=TRUE, horiz=TRUE, las=1, main="Car counts\nby transimission and cylinders", names.arg=c("V4", "V6", "V8"), legend.text=c("automatic", "manual"), args.legend=list(x="bottomright"))
```

### Barchart with ggplot2
**NOTE:** for qplot data type must be a factor
```{r}
library("ggplot2")
qplot(factor(mtcars$cyl), geom="bar")
```

### Dodged barchart with ggplot2
```{r}
qplot(factor(mtcars$cyl), geom="blank", fill=factor(mtcars$am), xlab="", ylab="", main="Car counts\nby transmission and cylinders") + 
   geom_bar(position="dodge") + 
   scale_x_discrete(labels=c("V4", "V6", "V8")) + 
   scale_y_continuous(breaks=seq(0, 12, 2)) + 
   theme_bw() + 
   coord_flip() + 
   scale_fill_grey(name="Trans", labels=c("automatic", "manual"))
```

## Piecharts
These are not recommended (see the comment at the end of help for the function `pie()`) and related functions are scarce in R.

### Piechart with base R
```{r}
pie(table(mtcars$cyl), labels=c("V4", "V6", "V8"), col=c("white", "gray", "black"), main="Cars by cylinders")
```

## Histograms
These look similar to barcharts but are used with continuous (or effectively so) data.

### Histogram with base R
We will plot a histogram for the gross horsepower variable in the `mtcars` dataset.
```{r}
mtcars$hp
```

Notice that the histogram has a *right* or *positive* skew
```{r}
hist(mtcars$hp)
```  

Now we plot a histogram with more detail, including narrower intervals for binning the data.
```{r}
hist(mtcars$hp, breaks=seq(0, 400, 25), col="gray", main="Horsepower", xlab="HP")
abline(v=c(mean(mtcars$hp), median(mtcars$hp)), lty=c(2, 3), lwd=2)
legend("topright", legend=c("mean HP", "mdian HP"), lty=c(2, 3), lwd=2)
```

Using a smaller bin width produces more detail in the histogram, but increases the risk of unimportant details being highlighted - the visualisation equivalent of model overfitting. There are algorithms that use the data itself to determine the best bin sizes. These are all implemented as part of `hist()` and can be specified using the `breaks` parameter, for example `breaks="Sturges"`.

### Histogram with ggplot2
Calling `qplot()` with a numeric vector as the only parameter plots a histogram by default.
```{r}
qplot(mtcars$hp)
```

Unlike `hist()`, which uses a data-driven algorithm to determine the number of bins in the histogram, the `ggplot2`package always uses a default of 30 bins. In the case of the horsepower data, this number is too high, a fact detected by the histogram-plotting code in `ggplot2`, hence the message to pick a better value.

We can produce more detail in a histogram more representative of the data by using additional functions:
```{r}
qplot(mtcars$hp, geom="blank", main="Horsepower", xlab="HP") + 
      geom_histogram(color="black", fill="white", breaks=seq(0, 400, 25), closed="right") +
      geom_vline(mapping=aes(xintercept=c(mean(mtcars$hp), median(mtcars$hp)), linetype=factor(c("mean", "median"))), show.legend=TRUE) +
      scale_linetype_manual(values=c(2, 3)) + labs(linetype="")
```

The `closed` parameter is used to specify whether the left or right 'edge' of the bin is included in the bin. When the argument is `right`, it is the left-hand-side edge that is included (i.e. the bin is closed on the right and open on the left).

**NOTE: In the following examples a data set available in R called `quakes` is used.**
```{r}
head(quakes)
```

## Boxplots

### Boxplot vs. Histogram
Let's start by comparing a histogram with a boxplot.
```{r}
hist(quakes$mag)
```
```{r}
boxplot(quakes$mag)
```

The default method for identifying outliers is to mark as such any values `v < Q1 - IQR*1.5` or `v > Q3 + IQR*1.5`. The method can be specified with the range parameter, the default for which is `range=1.5`.

### Side-by-Side boxplots with base R

We will work with the variable `stations`, which tells us how many monitoring stations registered an earthquake. We can use the `cut()` function to divide the set of station counts into three groups. The output of `cut()` is a factor with three levels, corresponding to the three ranges into which the variable is grouped. The function call `head(stations.fac)` prints the first few values of the factor i.e. the ranges to which the first few station counts fall into.

```{r}
stations.fac <- cut(quakes$stations, breaks=c(0, 50, 100, 150))
head(stations.fac)
```

Now we can display side-by-side boxplots for the value ranges. The tilde (~) in the data argument to boxplot can be interpreted as "by". So we are instructing `boxplot()` to plot the variable `quakes$mag` [grouped] by `stations.fac`.

```{r}
boxplot(quakes$mag~stations.fac, xlab="# stations detected", ylab="Magnitude", col="gray")
```

### Side-by-side boxplots with ggplot2
For ggplot2 the grouping variable `stations.fac` is passed in as the x-axis variable and the magnitude as the y-axis variable. The requirement for a boxplot as specified as the geometry (parameter `geom`).

```{r}
qplot(stations.fac, quakes$mag, geom="boxplot", xlab="# stations detected", ylab="Magnitude")
```

**NOTE: In the following examples a data set available in R called `mtcars` is used.**
```{r}
head(iris)
```

## Scatterplots

A scatterplot is used to visualise two numeric variables that are **related** in some way. This means that not every plot of points determined by numeric values is in fact a scatterplot. 

### Multiple subsets in scatterplot with base R
To display multiple subsets of a dataset in a scatterplot the subsets can be distinguished by the characters and colours used for the points. This can be done using a staged approach with base R.

```{r}
plot(iris[,4], iris[,3], type="n", xlab="Petal Width (cm)", ylab="Petal Length (cm)")
points(iris[iris$Species=="setosa", 4], iris[iris$Species=="setosa", 3], pch=19, col="black")
points(iris[iris$Species=="virginica", 4], iris[iris$Species=="virginica", 3], pch=19, col="gray")
points(iris[iris$Species=="versicolor", 4], iris[iris$Species=="versicolor", 3], pch=1, col="black")
legend("topleft", legend=c("setosa", "virginica", "versicolor"), col=c("black", "gray", "black"), pch=c(19, 19, 1))
```

An alternative is to create vectors that specify the colour and character for each individual point in the set, then using them in a single call to `plot()`.

```{r}
iris_pch <- rep(19, nrow(iris))
iris_pch[iris$Species=="versicolor"] <- 1
iris_col <- rep("black", nrow(iris))
iris_col[iris$Species=="virginica"] <- "gray"

plot(iris[, 4], iris[, 3], col=iris_col, pch=iris_pch, xlab="Petal Width (cm)", ylab="Petal Length (cm)")
```

### Matrix of scatterplots with base R
To display the relationships between more than two variables, a matrix of scatterplots, consisting of a scatterplot for each combination of two variables, can be used (in the code below the vectors `iris_pch` and `iris_col` created in the previous code-chunk are used).

```{r}
pairs(iris[,1:4], pch=iris_pch, col=iris_col, cex=0.75)
```

The parameters `upper.panel` and `lower.panel` can be used to control the inclusion of scaterplots above the diagonal. 

```{r}
pairs(iris[,1:4], pch=iris_pch, col=iris_col, cex=0.75, lower.panel=NULL)
```

### Multiple subsets in scatterplot with ggplot2
The code to create the same scatterplot earlier plotted with base R is:

```{r}
qplot(iris[, 4], iris[, 3], xlab="Petal width", ylab="Petal length", shape=iris$Species) +
   scale_shape_manual(values=4:6) +
   labs(shape="Species")
```

### Matrix of scatterplots with ggplot2
A matrix cannot easily be plotted using only ggplot2 but the GGally package can make it fairly easy. 

```{r}
library(GGally)
gg<-ggpairs(iris, mapping=aes(col=Species), axisLabels="internal")
print(gg, progress=F)
```
With this package, a complex matrix of graphs can be plotted using a single line of code.




## Exercises

JVKTODO

# Advanced visualilsation with base R

## Graphics devices
When the plotting functions used so far are called without any reference to a device, a default plotting device is opened and the plotting function calles applied to it. However, other devices may be opened.

### Opening new devices
* A function that refreshes a plotting window to produce a new image will create a new instance of the active device (the previous content will be lost). The behaviour in RStudio is to preserve previous plots, which can be accessed using the browser 'back' button.
* New devices are opened using `dev.new()`
* Only one device can be active at any one time 
* The banner title of the active device in R has **[*]** or **(ACTIVE)** appended to it, while in RStudio it is simply the device that is currently being displayed in the Plots window
* A newly opened device becomes the active one by default

As an exercise, close all the graphics devices, then plot stations histogram (cannot be run as a notebook chunk):

`hist(quakes$stations)`

Now create a new device using:

`dev.new()`

The new device's banner title should have the suffix marking it as active. If you create yet another device in the same way, the new device will be marked active and the previously created one inactive.

Now plot the following:

`plot(quakes$long, quakes$lat)`

The plot should be displayed on the device that was created most recently, as that is the active device.

### Switching between devices
To list the available devices, use the following command:

`dev.list()`

To switch to a different device use the following (the example shows number 3 but you should use the device number corresponding to the first plot made):

`dev.set(3)`

To check that the switch worked, add mean lines to the first plot:

`abline(v=mean(quakes$stations), lty=2)`

### Closing a device
To close a device call (3 is just an example device number):

`dev.off(3)`

As an exercise, close all the devices opened with `dev.new()`.

## Layouts

### Multiple plots on one device
Multiple plots are created by specifying a matrix of 'canvases' using the `mfrow` parameter. The following code specifies a matrix of 1 row by 2 columns. As the plots are created, they are placed in sequence in the cells of the matrix. Once the device is 'full' a new device is created with the same matrix of canvases etc. untill the mfrow parameter is changed. 

```{r}
dev.new(width=8, height=4)
par(mfrow=c(1, 2))
plot(quakes$long, quakes$lat, cex=0.02*quakes$stations, xlab="Longitude", ylab="Latitude")
hist(quakes$stations)
abline(v=mean(quakes$stations), lty=2)
```

### Complex layouts
The `layout()` function can be used for the specification of layouts more complex than a straightforward grid. 

A matrix is passed into the `layout()` function, which by its dimensions indicates the required dimensions of the grid on the graphics device and by the numeric value in each of its cells indicates the ordinal number of the plot that is to occupy the cell. The `layout()` function initialises the active device or creates a new device if none is opened. 

The example below specifies a 2 by 2 grid of cells to be used for plots, with plot 1 and 2 occupying the cells in the first row and plot 3 spanning across the entire bottom row. The `layout.show()` function can be used to see a visual plan of where plots will be placed.
```{r}
lay.mat <- matrix(c(1, 3, 2, 3), 2, 2)
layout(mat=lay.mat)
layout.show(n=max(lay.mat))
```

Now we use some data provided in the MASS package to create some plots.

```{r}
library("MASS")
layout(mat=lay.mat)
plot(survey$Wr.Hnd, survey$Height, xlab="Writing handspan", ylab="Height")
boxplot(survey$Height~survey$Smoke, xlab="Smoking frequency", ylab="Height")
barplot(table(survey$Exer), horiz=TRUE, main="Exercise")
```

The `layout()` function also allows the specification of relative widths and heights, further increasing the flexibility in laying out multiple plots. The only disadvantage of this method is that it does not allow returning to a plot once subsequent ones have been started. This means that data processing and preparation all needs to be completed before this kind of complex plot is created.

## Working with regions and margins
There are three regions in an R plot:

* plot region - the space including the plot itself

* figure region - the space including the plot and the space around it for axes labels and text

* outer region - additional space around the figure region (not included by default but can be added as space around the figure region)

The size of the margins and outer margins (the additional space in the figure and outer regions over the plot and figure regions, respectively) are specified, like the `mfrow` parameter, in a call to `par()` before any drawing begins. 

The default margins can be found using the following calls:

```{r}
par()$oma
par()$mar
```

The results are in units called 'lines', representing the height of a single line of text.

A simple plot can be used to illustrate this. The call to `box()` plots a box around the specified region, in the case of the example below the **figure region**.

```{r}
plot(1:10)
box(which="figure", lty=2)
```

Custom margins can be used instead, as in the following example. The `mtext()` function is used to print text in the plot, with the parameter `outer` specifying whether the text should be in the outer or figure region margins (the default is `outer=FALSE`, placing the text in the figure region margins). The parameter `line` is used to position the text relative to the region, in lines. 

```{r}
par(oma=c(1, 4, 3, 2), mar=4:7)
plot(1:10)
box("figure", lty=2)
box("outer", lty=3)
mtext("Figure region margins\nmar[ . ]", line=2, side=4)
mtext("Outer region margins\noma[ . ]", line=0.5, outer=TRUE)
```

The parameter `xpd` is used to specify if drawing to the plot should be clipped to the plot region. In some cases it is useful to be able to add elements to the plot that extend into the margin space. An example is in the following code chunk.

```{r}
par(oma=c(1, 1, 5, 1), mar=c(2, 4, 6, 4))
boxplot(mtcars$mpg~mtcars$cyl, xaxt="n", ylab="MPG")
box("figure", lty=2)
box("outer", lty=3)
arrows(x0=c(2, 2.5, 3), y0=c(44, 37, 27), x1=c(1.25, 2.25, 3), y1=c(31, 22, 20), xpd=FALSE)
text(x=c(2, 2.5, 3), y=c(45, 38, 28), c("V4 cars", "V6 cars", "V8 cars"), xpd=FALSE)
```

We would really like to see all the arrows in their entirety and to be able to read the associated text. This is achieved by passing in the value TRUE for `xpd`. The last line in the following chunk of code shows the use of the `srt` parameter, with which the rotation angle of a string can be specified. As `mtext()` does not have this parameter, using a combination of `srt` and `xpd=TRUE` is the only way of displaying slanted text in the margins of a plot.


```{r}
par(oma=c(1, 1, 5, 1), mar=c(2, 4, 6, 4))
boxplot(mtcars$mpg~mtcars$cyl, xaxt="n", ylab="MPG")
box("figure", lty=2)
box("outer", lty=3)
arrows(x0=c(2, 2.5, 3), y0=c(44, 37, 27), x1=c(1.25, 2.25, 3), y1=c(31, 22, 20), xpd=TRUE)
text(x=c(2, 2.5, 3), y=c(45, 38, 28), c("V4 cars", "V6 cars", "V8 cars"), xpd=TRUE)
text(x=1, y=40, labels="at an angle", col="red", srt=45, xpd=TRUE)
```


## Interactive reading of coordinates

To interactively determine coordinates of points in your plot, use `locator()` after creating a plot. This will not work within the notebook. Try it from the console. After calling `locator()` you will be able to click on the points in the plot for which you wish to determine the coordinates. Depending on the R environment, a right-click or ESC key will stop the process.


```{r eval=FALSE, include=FALSE}
plot(1, 1)
locator()
```

The result of the call to `locator()` can be saved for later use. Also, lines or points can be drawn immediately after the `locator()` session, as shown in the following example (run outside of notebook).

```{r eval=FALSE, include=FALSE}
plot(1, 1)
locator(type="o", pch=4, lty=2, lwd=3, col="red", xpd=TRUE)
```

The `locator()` function can be used for ad-hoc annotation, for example for placing a legend in a plot or just drawing a line. The parameter `n` specifies the number of points to be read.

```{r eval=FALSE, include=FALSE}
library("MASS")
plot(survey$Height~survey$Wr.Hnd, pch=16, col=c("gray", "black")[as.numeric(survey$Sex)], xlab="Writing handspan", ylab="Height")
legend(locator(n=1), legend=levels(survey$Sex), pch=16, col=c("gray", "black"))
lines(locator(n=2), col="blue")
```

## Customising plots
There are many parameters in R that can be used for customising plots. One way to use these is to start with a barebones plot that does not have any detail and then add the details in stages.

A default plot example:
```{r}
hp<-mtcars$hp
mpg<-mtcars$mpg
# we set the point scaling factors to be proportional to the weight of the vehicle
wtcex<-mtcars$wt/mean(mtcars$wt)
plot(hp, mpg, cex=wtcex)
```

### Suppressing details

The same plot with the extra space around the end points removed, using the parameters `xaxs` and `yaxs`:
```{r}
# the default for xaxs and yaxs is "r", which produces some space around the most extreme points
plot(hp, mpg, cex=wtcex, xaxs="i", yaxs="i")
```

There are two ways to produce a 'barebones' plot. The first way is to specify type 'none' for the axes, labels and box.
```{r}
plot(hp, mpg, cex=wtcex, xaxt="n", yaxt="n", bty="n", xlab="", ylab="")
```

The second is to prevent axes and annotations from being included. This method is shorter but does not allow fine-tuning.
```{r}
plot(hp, mpg, cex=wtcex, axes=FALSE, ann=FALSE)
```

### Boxes
Boxes are drawn around the plot using `box()` with parameter `bty` indicating the shape. This parameter can take the values 'o' (default), "l", "7", "c", "u", "]" or "n", with the the sematics of the values contained in their shapes. For example:

```{r}
plot(hp, mpg, cex=wtcex, axes=FALSE, ann=FALSE)
box(bty="]", lty=2, col="gray")
```

### Axes
The function `axis()` is used to separately plot an axis. It takes many parameters, some of which are demonstrated in the following examples.
```{r}
hpseq <- seq(min(hp), max(hp), length=10)
plot(hp, mpg, cex=wtcex, xaxt="n", bty="n", ann=FALSE)
axis(side=1, at=hpseq)
axis(side=3, at=round(hpseq))
```

```{r}
hpseq2 <- seq(50, 325, by=25)
plot(hp, mpg, cex=wtcex, axes=FALSE)
box(bty="l")
axis(side=2, tcl=-2, las=1, mgp=c(3, 2.5, 0))
axis(side=1, at=hpseq2, tcl=1.5, mgp=c(3, 1.5, 1))
```

### Text
Fonts are controlled with two parameters: `family` and `font`. The first one is the specific or generic family, while the second is the face type. 

* Generic families that are always available

+ Sans

+ Serif

+ Mono

* Font faces

+ 1 - normal 

+ 2 - bold

+ 3 - italic

+ 4 - bold and italic

Example of text, using different fonts:
```{r}
par(mar=c(3, 3, 3, 3))
plot(1, 1, type="n", xlim=c(-1, 1), ylim=c(0, 7), xaxt="n", yaxt="n", ann=FALSE)
text(0, 6, label="sans text (default)\nfamily=\"sans\", font=1")
text(0, 5, label="serif text\nfamily=\"serif\", font=1", family="serif", font=1)
text(0, 4, label="mono text\nfamily=\"mono\", font=1", family="mono", font=1)
text(0, 3, label="mono text (bold, italic)\nfamily=\"mono\", font=4", family="mono", font=4)
text(0, 2, label="sans text (italic)\nfamily=\"sans\", font=3", family="sans", font=3)
text(0, 1, label="serif text (bold)\nfamily=\"serif\", font=2", family="serif", font=2)
mtext("some", line=1, at=-0.5, cex=2, family="sans")
mtext("different", line=1, at=0, cex=2, family="serif")
mtext("fonts", line=1, at=0.5, cex=2, family="mono")
```

# Advanced graphics with ggplot2

## Comparing `qplot()` and `ggplot()`

Difference between `qplot()` and `ggplot`.

* `qplot()` emulates the base R `plot()` function, providing a one-step quick way of creating a plot

  + required data: vectors

* `ggplot()` in itself does not create a plot but requires calls to additional functions, but provides more power and flexibility in the building of plots

  + required data: data frame
  
To compare the two, we look at an earlier example produced with `qplot()`, this time using `ggplot()`.

Using `qplot()`:
```{r}
qplot(mtcars$hp, geom="blank", main="Horsepower", xlab="HP") + 
      geom_histogram(color="black", fill="white", breaks=seq(0, 400, 25), closed="right") +
      geom_vline(mapping=aes(xintercept=c(mean(mtcars$hp), median(mtcars$hp)), linetype=factor(c("mean", "median"))), show.legend=TRUE) +
      scale_linetype_manual(values=c(2, 3)) + labs(linetype="")
```

Using `ggplot()`:
```{r}
gg.static <- ggplot(data=mtcars, mapping=aes(x=hp)) + ggtitle("Horsepower") + labs(x="HP")
mtcars.mm <- data.frame(mm=c(mean(mtcars$hp), median(mtcars$hp)), stats=factor(c("mean", "median")))
gg.lines <- geom_vline(mapping=aes(xintercept=mm, linetype=stats), show.legend=TRUE, data=mtcars.mm)
gg.static + geom_histogram(color="black", fill="white", breaks=seq(0, 400, 25), closed="right") +
  gg.lines + scale_linetype_manual(values=c(2, 3)) + labs(linetype="")
```

## Smoothing and Shading

### LOESS
A non-parametric smoothing method can provide an idea of general trends in the data without requiring a model to be fitted. A common method is LOESS or LOWESS (Locally Weighted Scatterplot Smoothing), which ggplot2 implements and for which it provides a simple invocation mechanism.

To illustrate the creation of a smoothed trend curve with ggplot2 we will use the survey data from the MASS package. First we prepare the data by removing missing values. Then we plot `Height` against `Wr.Hnd` and include a smoothed trend curve, with a 95% confidence interval shaded around it.

```{r}
surv <- na.omit(survey[,c("Sex", "Wr.Hnd", "Height")])
ggplot(surv, aes(x=Wr.Hnd, y=Height)) + 
   geom_point(aes(col=Sex, shape=Sex)) +
   geom_smooth(method="loess")
```

The effort in base R required to produce the same plot is considerably greater.

```{r}
plot(surv$Wr.Hnd, surv$Height, col=surv$Sex, pch=c(16, 17)[surv$Sex])
smoother <- loess(Height~Wr.Hnd, data=surv)
handseq <- seq(min(surv$Wr.Hnd), max(surv$Wr.Hnd), length=100)
sm <- predict(smoother, newdata=data.frame(Wr.Hnd=handseq), se=TRUE)
lines(handseq, sm$fit)
polygon(x=c(handseq, rev(handseq)), y=c(sm$fit+2*sm$se, rev(sm$fit-2*sm$se)), col=adjustcolor("gray", alpha.f=0.5), border=NA)
```

The power of the ggplot2 version of the code is even more pronounced in the code for producing separate LOESS curves for the sexes.

```{r}
ggplot(surv, aes(x=Wr.Hnd, y=Height, col=Sex, shape=Sex)) + geom_point() + geom_smooth(method="loess")
```

The `span` parameter is used to specify the proportion of the data used in each step of the localised estimation procedure. The default value is 0.75.

We recreate the first of the loess plots twice more, with different values for this parameter.

```{r}
ggplot(surv, aes(x=Wr.Hnd, y=Height)) + 
   geom_point(aes(col=Sex, shape=Sex)) +
   geom_smooth(method="loess", span=0.4)
```

```{r}
ggplot(surv, aes(x=Wr.Hnd, y=Height)) + 
   geom_point(aes(col=Sex, shape=Sex)) +
   geom_smooth(method="loess", span=1.5)
```


### KDE

Kernel density estimation (KDE) is a method for producing a smooth estimate of a probability density function based on observed data.

The following will plot an estimate of the probability density function for the `airquality` data variable `Temp`.
```{r}
ggplot(data=airquality, aes(x=Temp)) + geom_density()
```

Now we create a plot with separate estimated probability density functions for the different months that feature in the data.
```{r}
air <- airquality
air$Month <- factor(air$Month, labels=c("May", "June", "July", "August", "September"))
ggplot(data=air, aes(x=Temp, fill=Month)) + 
   geom_density(alpha=0.4) + 
   ggtitle("Monthly temperature probability densities") +
   labs(x="Temp (F)", y="Kernel estimate")
```

## Multiple Plots and Variable-Mapped Facets
The functions in ggplot2 do not work with `mfrow` and `layout()`, but there are other mechanisms that can be used for placing multiple plots on one device with ggplot2.

A quick way of arranging **multiple independent plots in a single image** is with the function `grid.arrange` from the **gridExtra** package.

To illustrate the use of this package we re-use the `air` object we created earlier and define three ggplot objects.
```{r}
gg1 <- ggplot(air, aes(x=1:nrow(air), y=Temp)) + 
   geom_line(aes(col=Month)) + 
   geom_point(aes(col=Month, size=Wind)) +
   geom_smooth(method="loess", col="Black") +
               labs(x="Time (days)", y="Temperature (F)")
gg2 <- ggplot(air, aes(x=Solar.R, fill=Month)) +
   geom_density(alpha=0.4) +
   labs(x=expression(paste("Solar radiation (", ring(A),")")), y="Kernel estimate")
gg3 <- ggplot(air, aes(x=Wind, y=Temp, color=Month)) +
   geom_point(aes(size=Ozone)) +
   geom_smooth(method="lm", level=0.9, fullrange=FALSE, alpha=0.2) +
   labs(x="Wind speed (MPH)", y="Temperature (F)")
```

Now, after including the gridExtra package in our library (the package must be installed beforehand), we can call the function `grid.arrange()` to display all three plots combined into a single image.
```{r}
library("gridExtra")
grid.arrange(gg1, gg2, gg3)
```

In the case that faceting is required i.e. the creation of **several plots** of the same variables, distinguished **by values of one or more categorical variables**, the functions to use are `facet_wrap()` and `facet_grid()`.

Let's use the temperature plot produced earlier:
```{r}
ggp <- ggplot(data=air, aes(x=Temp, fill=Month)) + 
   geom_density(alpha=0.4) + 
   ggtitle("Monthly temperature probability densities") +
   labs(x="Temp (F)", y="Kernel estimate")
```

We can separate the plots for different months in the following way:
```{r}
ggp + facet_wrap(~Month)
```

Specifying `scales="free"` scales the plots individually (only one axis can be made free by using `scales="free_x"` or `scales="free_y"`)
```{r}
ggp + facet_wrap(~Month, scales="free")
```

Another parameter is `nrow`:
```{r}
ggp + facet_wrap(~Month, nrow=1)
```

The function `facet_grid` works with two faceting variables, one's values changing between rows and the others' between columns. These are specified in the format `var1~var2` and if only one variable is used the other can be replaced with a dot. 
```{r}
ggp + facet_grid(Month~.)
```

To demonstate the use of `facet_grid()` with two variables, we use the dataset `mpg` found in the ggplot2 package.
```{r}
ggplot(ggplot2::mpg, aes(x=displ, y=cty)) + geom_point(aes(col=manufacturer)) + 
   labs(x="Engine displacement (l)", y="City miles per gallon") +
   facet_grid(drv~cyl)
```

## Interactive plots

The package **ggvis** can create interactive plots. 

The ggvis package uses the pipe operator `%>%` rather than a `+` to chain commands and its drawing function names start with `layer_` rather than `geom_` but otherwise operates similarly to ggplot2.

Let's prepare some data from the `survey` dataset in the MASS package.
```{r}
library("MASS")
surv <- na.omit(survey[, c("Sex", "Wr.Hnd", "Height", "Smoke", "Exer")])
```

Now lets create our first plot with ggvis. The 'tilda' character as a prefix to a variable name indicates that the variable is from the dataframe.
```{r}
library("ggvis")
surv %>% ggvis(x=~Height) %>% layer_histograms()
```

The plot is produced in the form of web graphics. Notice the 'cog' symbol that is included with the plot and which allows you a minimal amount of general interaction with the plot.

Now we go a bit further with the following line of code. The assignment operator `:=` is used instead of `=` where a fixed value is being passed in, rather than a value subject to change, rather like an aesthetic mapping in ggplot.
```{r}
surv %>% ggvis(x=~Height) %>% layer_histograms(width=input_slider(1, 15, label="Binwidth:"), fill:="gray")
```

Because the output of ggvis is web-based, it is not included in the notebook but shown in the RStudio viewer. The slider in the output pane allows us to change the bin width of the displayed histogram.

Other kinds of controls can be included in the plot. Let's try another example, starting with a basic plot.
```{r}
surv %>% ggvis(x=~Wr.Hnd, y=~Height, size:=200, opacity:=0.3) %>% layer_points()
```

To this we can add controls.
```{r}
filler <- input_radiobuttons(c("Sex"="Sex", "Smoking status"="Smoke", "Exercise frequency"="Exer"), map=as.name, label="Color points by...")
sizer <- input_slider(10, 300, label="Point size:")
opacityer <- input_slider(0.1, 1, label="opacity:")
surv %>% ggvis(x=~Wr.Hnd, y=~Height, fill=filler, size:=sizer, opacity:=opacityer) %>% layer_points() %>%
   add_axis("x", title="Handspan") %>% add_legend("fill", title="")
```

Finally, an example where a slider is used to change the span of a smoothed trend curve.
```{r}
surv %>% ggvis(x=~Wr.Hnd, y=~Height, fill=~Sex) %>% group_by(Sex) %>%
   layer_smooths(span=input_slider(0.3, 1, value=0.75, label="Smoothing span:"), se=TRUE) %>%
   layer_points() %>% add_axis("x", title="Handspan")
```

# Colour

## Representing colours

The strings representing the **8 colours of the R default palette** are:
```{r}
palette()
```
These strings, or numbers from 1 to 8, can be used to specify the 8 colours.


The **RGB components** (saturations or intensities) of a colour are returned by function `col2rgb()`. The function takes a vector of colours and returns the red, green and blue intensities (**RGB triplet**) for each colour in the vector.
```{r}
col2rgb(c("black", "green3", "pink"))
```

A colour can also be represented with a hexadecimal number. The function `rgb()` converts RGB triplets into these hexadecimal values.
```{r}
rgb(t(col2rgb(c("black", "green3", "pink"))), maxColorValue=255)
```

The following function plots points in different colours, with RGB triplet and hexadecimal labels. We call the function with a vector of 14 colours.
```{r}
pcol <- function(cols) {
   n <- length(cols)
   dev.new(width=7, height=7)
   par(mar=rep(1,4))
   plot(1:5, 1:5, type="n", xaxt="n", yaxt="n", ann=FALSE)
   for (i in 1:n) {
      pt <- locator(1)
      rgbval <- col2rgb(cols[i])
      points(pt, cex=4, pch=19, col=cols[i])
      text(pt$x+1, pt$y, family="mono", 
           label=paste("\"", cols[i], "\"", "\nR: ", rgbval[1], " G: ", rgbval[2], " B: ", rgbval[3], 
                       "\nhex: ", rgb(t(rgbval), maxColorValue=255), sep=""))
   }
}
mycols <- c("black", "blue", "royalblue2", "pink", "magenta", "purple", "violet", "coral", "lightgray", "seagreen4", "red", "red2", "yellow", "lemonchiffon3")
```

Now we can call `pcol(mcols)` (from the console) and click on 14 points to tell the function where to place information about the 14 colours. Note that this will not work from the R notebook.

## Palettes
There are a number of built-in palettes in R. Vectors of equally spaced colours are returned by pallete functions that take the number of required colours as a parameter. The exception is the function `gray()` which takes a vector parameter containing the required levels of gray, specified using numbers between 0 (total black) and 1 (tatal white).
```{r}
N <- 600
rbow <- rainbow(N)
heat <- heat.colors(N)
terr <- terrain.colors(N)
topo <- topo.colors(N)
cm <-cm.colors(N)
gry1 <- gray.colors(N)
gry2 <- gray(level=seq(0, 1, length=N))
```

Now we visualise the colour vectors created from the palettes.
```{r}
dev.new(width=8, height=3)
par(mar=c(1, 8, 1, 1))
plot(1, 1, xlim=c(1, N), ylim=c(0.2, 7.5), type="n", xaxt="n", yaxt="n", ann=FALSE)
points(rep(1:N, 7), rep(7:1, each=N), pch=19, cex=3, col=c(rbow, heat, terr, topo, cm, gry1, gry2))
axis(2, at=7:1, labels=c("rainbow", "heat.colors", "terrain.colors", "topo.colors", "cm.colors", "gray.colors", "gray"), family="mono", las=1)
```

The function `colorRampPalette()` creates a palette function like the ones used above, from colours passed in as parameters. 
```{r}
puryel.colors <- colorRampPalette(colors=c("purple", "yellow"))
blues <- colorRampPalette(colors=c("navyblue", "lightblue"))
fours <- colorRampPalette(colors=c("black", "hotpink", "seagreen4", "tomato"))
irish.flag <- colorRampPalette(colors=c("green", "white", "orange"))
```

Now we repeat the plot above but with our custom palettes.
```{r}
py <- puryel.colors(N)
bls <- blues(N)
frs <- fours(N)
irl <- irish.flag(N)
dev.new(width=8, height=2)
        
par(mar=c(1, 8, 1, 1))
plot(1, 1, xlim=c(1, N), ylim=c(0.2, 4.5), type="n", xaxt="n", yaxt="n", ann=FALSE)
points(rep(1:N, 4), rep(4:1, each=N), pch=19, cex=3, col=c(py, bls, frs, irl))
axis(2, at=4:1, labels=c("puryel.colors", "blues", "fours", "irish.flag"), family="mono", las=1)
```

## Using colours to represent continuous variables
There are two ways of doing this. One way is to **turn the continuous variable into a categorical one, then use discrete colours to index the categorical variable**.

We use the `survey` data from the MASS package again. We alsocreate a custom palette function and 'categorise' the variable `surv$NW.Hnd`. We prepare the colours for the plot. Finally, we plot using two other variables for x and y.
```{r}
surv <- na.omit(survey[, c("Wr.Hnd", "NW.Hnd", "Height")])
# create palette
NW.pal <- colorRampPalette(colors=c("red4", "yellow2"))
k <- 5
# categorisation of surv$NW.Hnd
NW.fac <- cut(surv$NW.Hnd, breaks=seq(min(surv$NW.Hnd), max(surv$NW.Hnd), length=k+1), include.lowest=TRUE)
# colour vector with a colour for each point
NW.cols <- NW.pal(k)[as.numeric(NW.fac)]
#plot
plot(surv$Wr.Hnd, surv$Height, col=NW.cols, pch=19)
```

The other way of representing a continuous variable with colour is **via normalisation**. First, we write a function to normalize the values of the continuous variable to the range (0,1).
```{r}
normalize <- function (datavec) {
   lo <- min(datavec, na.rm=TRUE)
   up <- max(datavec, na.rm=TRUE)
   datanorm <- (datavec-lo)/(up-lo)
   return(datanorm)
}
```

The function we need now is `colorRamp()`. It creates a function that takes a vector parameter containing the required colour levels, specified using numbers between 0 and 1 (like the function `gray()` used earlier). The colours returned by the created function are in RGB triplets and must be converted using `rgb()` to hexadecimal before they can be used in `plot()`. Once the colours are prepared, the plot is straightforward.
```{r}
NW.pal2 <- colorRamp(colors=c("red4", "yellow2"))
NW.cols2 <- rgb(NW.pal2(normalize(surv$NW.Hnd)), maxColorValue=255)
plot(surv$Wr.Hnd, surv$Height, col=NW.cols2, pch=19)
```

While in this example the difference is not noticeable, the normalization method is to be given preferrence, as it better correpsonds to the continuous nature of the variable that is represented.

## Color legends

Colour legends can be created with function `colorlegend()` from library `shape`.
```{r}
library("shape")
plot(surv$Wr.Hnd, surv$Height, col=NW.cols2, pch=19, xlab="Writing handspan (cm)", ylab="Height (cm)")
colorlegend(NW.pal(200), zlim=range(surv$NW.Hnd), zval=seq(13, 23, by=2), posx=c(0.3, 0.33), posy=c(0.5, 0.9), main="Nonwriting handspan")
```

Now a call with slightly different parameters, placing the legend in the margin.
```{r}
par(mar=c(5, 4, 4, 6))
plot(surv$Wr.Hnd, surv$Height, col=NW.cols2, pch=19, xlab="Writing handspan (cm)", ylab="Height (cm)")
colorlegend(NW.pal(200), zlim=range(surv$NW.Hnd), zval=13.5:22.5, digit=1, posx=c(0.89, 0.91), main="Nonwriting\nhandspan")
```

## Opacity
We can add an opacity parameter, alpha, into the colour functions. 
```{r}
keycols <- c("blue", "red", "yellow")
depth.pal <- colorRampPalette(keycols)
depth.pal2 <- colorRamp(keycols)

depth.cols <- rgb(depth.pal2(normalize(quakes$depth)), maxColorValue=255, alpha=0.6*255)

plot(quakes$mag, quakes$stations, pch=19, cex=2, col=depth.cols, xlab="Magnitude", ylab="No. of stations")
colorlegend(adjustcolor(depth.pal(20), alpha.f=0.6), zlim=range(quakes$depth), zval=seq(100, 600, 100), 
            posx=c(0.3, 0.32), posy=c(0.5, 0.9), left=TRUE, main="Depth")
```

## Other colour functionality
Other colour formats are supported:

* hue-saturation-value (HSV) - function `hsv()`
* hue-chroma-luminance (HCL) - function `hcl()`

Useful colour packages:

* colorspace - for converting between formats
* RColorBrewer - more options for creating palettes

# Showing the third dimension

## Basic plots
The most common method for this is the `scatterplot3d()` function from the package by the same name.

The following example uses the `iris` data set.
```{r}
pwid <- iris$Petal.Width
plen <- iris$Petal.Length
swid <- iris$Sepal.Width
slen <- iris$Sepal.Length

library("scatterplot3d")
scatterplot3d(x=pwid, y=plen, z=swid)
```

The same plot with some enhancements for better perception of depth:
```{r}
scatterplot3d(x=pwid, y=plen, z=swid, highlight.3d=TRUE, type="h", 
              lty.hplot=2, lty.hid=3, xlab="Petal width", ylab="Petal length", 
              zlab="Sepal width", main="Iris Flower Measurements")
```
In the plot above, `highlight.3d=TRUE` instructs the function to apply color transitioning from red to black as an indicator of depth (distance along the y-axis). The `lty.hplot` parameter is the type of the 'height-lines' (in this case 2 i.e. dashed), while `lty.hid` is the type of line used for the hidden lines of the box (in this case 3 i.e. dotted).


Finally, we plot the iris set including a colour palette for the fourth variable (sepal length) and using different point shapes for the different species of iris.

```{r}
keycols <- c("purple", "yellow2", "blue")
slen.pal <- colorRampPalette(keycols)
slen.pal2 <- colorRamp(keycols)
slen.cols <- rgb(slen.pal2(normalize(slen)), maxColorValue=255)

scatterplot3d(x=pwid, y=plen, z=swid, color=slen.cols, 
              pch=c(19, 17, 15)[as.numeric(iris$Species)], type="h",
              lty.hplot=2, lty.hide=3, xlab="Petal width",
              ylab="Petal length", zlab="Sepal width",
              main="Iris Flower Measurements")
legend("bottomright", legend=levels(iris$Species), pch=c(19, 17, 15))
colorlegend(slen.pal(200), zlim=range(slen), zval=5:7, digit=1, 
            posx=c(0.1, 0.13), posy=c(0.7, 0.9), left=TRUE, main="Sepal length")
```



## Bivariate surface plotting
A bivariate surface is formed by the values of a continuous dependent variable as a function of two continuous independent variables. As plotting a truly continuous surface is impossible in practice, a finite 2D grid of evenly spaced coordinates on the independent variable axes (the evaluation grid) is used for plotting such functions. The matrix of function values corresponding to these grid points is called the **z-matrix**.

Let's construct an evaluation grid:
```{r}
xcoords <- 1:6
ycoords <- 1:4
xycoords <- expand.grid(x=xcoords, y=ycoords)
xycoords
```

The following code shows the first 24 letters of the alphabet (in order) matched with the coordinates created earlier ordered by column-wise traversal of a matrix with x representing rows and y representing columns.
```{r}
z <- letters[1:24]
cbind(xycoords, z)
```

The z-values can be placed into a matrix by just passing in the vector `z`. 
```{r}
nx <- length(xcoords)
ny <- length(ycoords)
zmat <- matrix(z, nrow=nx, ncol=ny)
zmat
```

### Contour plots
An already existing matrix of values is used in the first example. The `volcano` data set contains elevation measurements for a matrix of points covering a square area containing a volcano in New Zealand.
```{r}
dim(volcano)
contour(x=1:nrow(volcano), y=1:ncol(volcano), z=volcano, asp=1)
```

The second example is of a **parametric response surface**. This is the surface formed by values predicted from two independent variables by a parametric model. Let's use the `mtcars` dataset to model the miles-per-galon values based on horsepower and weight.
```{r}
car.fit <- lm(mpg~hp*wt, data=mtcars)
car.fit
```

We decide on 20 points on each axis for prediction and set up the grid to cover the ranges for `mtcars$hp` and `mtcars$wt`.
```{r}
len <- 20
hp.seq <- seq(min(mtcars$hp), max(mtcars$hp), length=len)
wt.seq <- seq(min(mtcars$wt), max(mtcars$wt), length=len)
hp.wt <-expand.grid(hp=hp.seq, wt=wt.seq)
```

Now we apply the model to the points in the matrix, then place the vector of results into a z-matrix.
```{r}
car.pred <- predict(car.fit, newdata=hp.wt)
car.pred.mat <- matrix(car.pred, nrow=len, ncol=len)
```

Finally, we can plot the contour plot, showing the lines of constant predicted values for the model.
```{r}
contour(x=hp.seq, y=wt.seq, z=car.pred.mat, levels=32:8, lty=2, lwd=1.5, 
        xaxs="i", yaxs="i", xlab="Horsepower", ylab="Weight", 
        main="Mean MPG model")
```

